<!DOCTYPE html>
<html lang="en">
<!--
PointsRaceWeb
-------------

A browser-based application for scoring Points, Madison, Tempo and Scratch races.
Press "Show Help" for disclaimer and details.

Created by Edward Sitarski (edward.sitarski@gmail.com).
Toronto, Ontario, Canada, October 2023

-->

<link rel="icon" type="image/x-icon" href="data:image/png;base64,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eG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6R0lNUD0iaHR0cDovL3d3dy5naW1wLm9yZy94bXAvIgogICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgIHhtcE1NOkRvY3VtZW50SUQ9ImdpbXA6ZG9jaWQ6Z2ltcDpiOTdhYjMyNi1jMWE5LTRkMzAtODJmOS1hZDk5ZTk3ZjhlZDgiCiAgIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ZTMzNjdmMDItMDAxNy00NzBmLTkyZmMtMjRiMDgzNGEwNjZkIgogICB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6NTRkMjlkZWMtNzA1OC00MmRiLThjMzEtYjE0MGE1ODcwMWJkIgogICBkYzpGb3JtYXQ9ImltYWdlL3BuZyIKICAgR0lNUDpBUEk9IjIuMCIKICAgR0lNUDpQbGF0Zm9ybT0iTGludXgiCiAgIEdJTVA6VGltZVN0YW1wPSIxNjk5MTAyMTAxODI3NDIzIgogICBHSU1QOlZlcnNpb249IjIuMTAuMzAiCiAgIHRpZmY6T3JpZW50YXRpb249IjEiCiAgIHhtcDpDcmVhdG9yVG9vbD0iR0lNUCAyLjEwIj4KICAgPHhtcE1NOkhpc3Rvcnk+CiAgICA8cmRmOlNlcT4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MmYyNTJlMDEtMTkxZC00NDExLTg2NGMtOWQ3ZmNlYjk1YzdkIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJHaW1wIDIuMTAgKExpbnV4KSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyMy0xMS0wNFQwODo0ODoyMS0wNDowMCIvPgogICAgPC9yZGY6U2VxPgogICA8L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4Zci6uAAAABmJLR0QAxwDDALzzSFgKAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5wsEDDAVhKYMoAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAMtSURBVDjLhY/PT5t1AIc/3/d3+761pW/3QttReDvrSAUcOkCJJuri1MO20zYvHryYcDIeFv8CD/Nilhh38KIXzYwkHrYZE9GBQRBQB+kGA/oDKP0NfelL+9L3Vz158IA+9+dJHoL/4fPbD6+6pHF5dKx4NyHkzwmdumrZTYoJJu2aE7bIf8m12mPx519ye8XFu/5LVx5D9S0AuwJazR5ou0mYShInBmx7OaZp+/cNQ0+2Gi3CNRbRamZglKMoPSgjBhl10GBOCtTrzfey+WpyZ98gCR7IztNo84PQ82k4rIlGtgpJOQ/qpADHeT7pDop3Dgs7qBweo5Tz4dTpBF5+/x10DT4Nd6IHwcvyyQuZzNTNTGb7w6GhUVZb0yD2CZib/Q2BfQ56W4fDeLC6tvDvhenpHO/z9TqDg3PRVOrRB8+PjrOSICB/tA0l4MWLrw5gY2MfYeclGHQfIp0Q6H/kG18uXd9b3fvVQ9bfjVOzb0asdD9dXSZo5MEoIjoMB+3wCLZtoi8hg5Am/CG9QwAgl/uOL1VC92rrMxeip9IYHv4W5MkEtKKFw9UYHF1C+cIAOt1dUNUgGIYxCKEWeD5whymV7jGO49z3dVVfF8fiYFvd+P5rE7zIofBwAzGzAckVQIki1PhToCjGtW3qL8tqfaEob31DybKsAFBziyk4uoXtH/MIS69A8g9AifSianegReLw2QKKBQ2bm9tUtVqbEAT6tqZN88zBAVMBhFk21KVu7mog8KJSrmN4IApPiEOpOAdGOkCBSDjrJjD8QgQNo4GlpSeCJPl7SKXy4OO19UcfjY2O0FadQ/NIh8nrmP8hBfGIh+dMHH/+nsLbV2KQY8+g9McOTp8PgPU8i5u3PrtGOY52I9yj0jzvw+Z8FrZwAJYlCPTzOHtpBMSXQP/IayhpLbiuie7nwgjI4zBN1hGIUGAoirK3tjJsb68f0XEOLuWgaRzD6xXgD+hgObPTr7bNdNpcLleOzwXkM8xWulBYWVn59OIbF+dJNvvTVcD4qlgsetptEzxPAYRFXFVcwJsWBPqWaUrLwSC1NDWVZmdSMxiKDLmTk5MWAPwNJO9bYZ1CQOgAAAAASUVORK5CYII=" />
<head>
<title id="idTitle">PointsRaceWeb</title>
<style>
body {
    font: normal 14px 'Roboto', sans-serif;
}

@media print {
  .d-print-none {
    display: none !important;
  }
}

/*
@media (prefers-color-scheme: dark) {
	body {
		background: #121212;
		color: rgba(255, 255, 255, 0.8);
	}
	dialog {
		background: #121212;
		color: rgba(255, 255, 255, 0.8);
	}
}
@media (prefers-color-scheme: light) {
	body {
		background: #ffff;
		color: rgba(0, 0, 0, 0.9);
	}
	dialog {
		background: #ffff;
		color: rgba(0, 0, 0, 0.9);
	}
}
*/

.divider{margin: 0.5rem; display: inline;}

td {
	vertical-align: top;
}

#idActions {
	border-right: 3px solid black;
}

.hover-rows tr:hover {
	background-color: #DCDCDC;
}

.text-right {
  text-align: right;
}

#idBibText {
	font-size: 110%;
}

.button3 {
	display: inline-block;
	outline: 0;
	cursor: pointer;
	padding: 5px 16px;
	font-size: 14px;
	font-weight: 500;
	line-height: 20px;
	vertical-align: middle;
	border: 1px solid;
	border-radius: 6px;
	color: #ffffff;
	background-color: #2ea44f;
	border-color: #1b1f2326;
	box-shadow: rgba(27, 31, 35, 0.04) 0px 1px 0px 0px, rgba(255, 255, 255, 0.25) 0px 1px 0px 0px inset;
	transition: 0.2s cubic-bezier(0.3, 0, 0.5, 1);
	transition-property: color, background-color, border-color;
	margin: 4px;
	:hover {
		background-color: #2c974b;
		border-color: #1b1f2326;
		transition-duration: 0.1s;
	}
}

.result-button {
	display: inline-block;
	outline: 0;
	cursor: pointer;
	padding: 5px 16px;
	font-size: 110%;
	font-weight: 500;
	line-height: 20px;
	vertical-align: middle;
	border: 1px solid;
	border-radius: 6px;
	color: #ffffff;
	background-color: #2ea44f;
	border-color: #1b1f2326;
	box-shadow: rgba(27, 31, 35, 0.04) 0px 1px 0px 0px, rgba(255, 255, 255, 0.25) 0px 1px 0px 0px inset;
	transition: 0.2s cubic-bezier(0.3, 0, 0.5, 1);
	transition-property: color, background-color, border-color;
	:hover {
		background-color: #2c974b;
		border-color: #1b1f2326;
		transition-duration: 0.1s;
	}
}

.note-button {
	display: inline-block;
	outline: 0;
	cursor: pointer;
	padding: 5px 16px;
	font-size: 110%;
	font-weight: 500;
	line-height: 20px;
	vertical-align: middle;
	border: 1px solid;
	border-radius: 6px;
	color: #ffffff;
	background-color: #2ea44f;
	border-color: #1b1f2326;
	box-shadow: rgba(27, 31, 35, 0.04) 0px 1px 0px 0px, rgba(255, 255, 255, 0.25) 0px 1px 0px 0px inset;
	transition: 0.2s cubic-bezier(0.3, 0, 0.5, 1);
	transition-property: color, background-color, border-color;
	:hover {
		background-color: #2c974b;
		border-color: #1b1f2326;
		transition-duration: 0.1s;
	}
}

button.round {
  background-color: #2ea44f;
  color: white;
  border: none;
  padding: 5px;
  font-size: 31px;
  height: 1.5em;
  width: 1.5em;
  box-shadow: 0 2px 4px darkslategray;
  border-radius: 50%;
  cursor: pointer;
}
      
/* bootstrap-style buttons */
.btn {
  appearance: none;
    -webkit-appearance: none;
  font-family: sans-serif;
  font-size: 110%;
  cursor: pointer;
  padding: 6px;
  min-width: 70px;
  border: 0px;
    -webkit-transition: background-color 100ms linear;
    -ms-transition: background-color 100ms linear;
     transition: background-color 100ms linear;
}

.btn:focus, .btn.focus {
  outline: 0;
}

.btn-round-1 {
  border-radius: 8px;
}

.btn-round-2 {
  border-radius: 20px;
}

.btn-dark {
  background: #000;
  color: #ffffff;
}

.btn-dark:hover {
  background: #212121;
  color: #ffffff;
}

.btn-light {
  background: #ededed;
  color: #000;
}

.btn-light:hover {
  background: #dbdbdb;
  color: #000;
}

.btn-primary {
  background: #3498db;
  color: #ffffff;
}

.btn-primary:hover {
  background: #2980b9;
  color: #ffffff;
}

.btn-success {
  background: #2ecc71;
  color: #ffffff;
}

.btn-success:hover {
  background: #27ae60;
  color: #ffffff;
}

.btn-warning {
  background: #f1c40f;
  color: #ffffff;
}

.btn-warning:hover {
  background: #f39c12;
  color: #ffffff;
}

.btn-danger {
  background: #e74c3c;
  color: #ffffff;
}

.btn-danger:hover {
  background: #c0392b;
  color: #ffffff;
}

.slide-left {
  animation: 1.25s slide-left;
}
@keyframes slide-left {
  from {
    margin-left: 100%;
  }
  to {
    margin-left: 0%;
  }
}

.center {
  display: flex;
  align-items: center;
  height: 50px;
}

</style>
<script>

"use strict";

const version = "PointsRaceWeb 1.1";

Array.prototype.clear = function() {
   this.splice(0, Infinity);
};

class Enum {
	constructor( ...keys ) {
		this._inverse = new Map();
		this.keys = [...keys];
		keys.forEach( (key, i) => { this._inverse.set(i, key); this[key] = i; } );
		Object.freeze( this );
	}
	name( i ) { return this._inverse.get(i); }
	value( key ) { return this[key]; }
}

const Status = new Enum('finisher', 'dnf', 'dns', 'dsq');

class SprintResult {
	constructor( sprint, place, points, bib ) {
		this.sprint = sprint;
		this.place = place;
		this.points = points;
		this.bib = Math.abs(bib);
	}
}

function formatNonZero( v ) {
	return v !== 0 ? v.toString() : '';
}

const finishUnplaced = 32767; // Placeholder for unplaced riders.

class Rider {
	constructor( bib ) {
		this.bib = bib;

		this.status = Status.finisher;
		this.pointsOnSprint = new Map(); // Points awarded per sprint starting from 1.
		this.pointsTotal = 0;
		this.upDown = 0;
		this.startingPoints = 0;
		this.finishOrder = finishUnplaced;
		this.pullSequence = 0;
	}
	get isPulled() { return this.pullSequence !== 0; }
	get isFinisher() { return this.status === Status.finisher; }

	computePointsTotal( e ) {
		if( !this.isFinisher ) {
			this.pointsTotal = 0;
			return;
		}
		this.pointsTotal = this.startingPoints;
		for( let points of this.pointsOnSprint.values() )
			this.pointsTotal += points;
		this.pointsTotal += this.upDown * e.pointsForUpDown;
	}

	get getStatusDisplay() { return Status.name(this.status).toUpperCase(); }

	cmpPoints( r ) {
		return (
			(this.status - r.status ) ||
			-( this.pointsTotal - r.pointsTotal ) ||
			( this.finishOrder - r.finishOrder ) ||
			( this.bib - r.bib )
		);
	}
	eqPoints( r ) {
		return this.status === r.status && this.pointsTotal === r.pointsTotal && this.finishOrder === r.finishOrder;
	}

	cmpTempo( r ) { return this.cmpPoints(r); }
	eqTempo( r ) { return this.eqPoints(r); }

	cmpScratch( r ) {
		return (
			( this.status - r.status ) ||
			-( this.upDown - r.upDown ) ||
			( this.finishOrder - r.finishOrder ) ||
			( this.bib - r.bib )
		);
	}
	eqScratch( r ) {
		return this.status === r.status && this.upDown === r.upDown && this.finishOrder === r.finishOrder;
	}
}

const ActionType = new Enum(
	'sprint',
	'lapUp',
	'lapDown',
	'pul',
	'dnf',
	'dns',
	'dsq',

	'breakGroup',
	'chaseGroup',
	'otb',
	'nml',
	'cmpct'
);

const actionResult = new Set( [ActionType.sprint, ActionType.lapUp, ActionType.lapDown, ActionType.pul, ActionType.dnf, ActionType.dns, ActionType.dsq] );
const actionNote = new Set( [ActionType.breakGroup, ActionType.chaseGroup, ActionType.otb, ActionType.nml, ActionType.cmpct] );

class Action {
  constructor( actionType = ActionType.sprint, bibText='' ) {
    this.actionType = actionType;
    this.bibText = '';
    this.setBibText( bibText || '' );
  }
  
  cmpEq( a ) {
	  return this.actionType === a.actionType && this.bibText === a.bibText;
  }

  get isActionResult() { return actionResult.has( this.actionType ); }
  get isActionNote() { return actionNote.has( this.actionType ); }

  getBibsFromText() {
    let bibs = this.bibText.replaceAll('-', ' -').split( /[^0-9-]+/ );
    let bibNums = [], bibsSeen = new Set();
    for( let b of bibs ) {
      let n = parseInt( b, 10 );
      if( !Number.isNaN(n) && n !== 0 && !bibsSeen.has(n) ) {
        bibNums.push( n );
        bibsSeen.add( n );
      }
    }
    if( bibNums.length > 0 && bibNums[0] < 0 )	// First can't be tied.
		bibNums[0] *= -1;
    return bibNums;
  }

  setBibTextFromList( bibNums ) {
    this.bibText = bibNums.join( ' ' );
  }

  normalizeBibs() {
    this.setBibTextFromList( this.getBibsFromText() );
  }
  
  setBibChildren( parent ) {
	    // Set the children of the parent in bib groups.
		const nbsp = '\u00A0';
		const bibsPerRow = 5;
		let bibsFromText = this.getBibsFromText();
		let bibNodes = [];

		// Group the bibs with non-breaking spaces.
		for( let i = 0; i < bibsFromText.length; i += bibsPerRow )
			bibNodes.push( document.createTextNode( bibsFromText.slice(i, i+bibsPerRow).join(nbsp) ) );
		 
		// Insert <br> between groups.
		let children = [];
		for( let i = 0; i < bibNodes.length; ++i ) {
			if( i !== 0 )
				children.push( document.createElement('br') );
			children.push( bibNodes[i] );
		}
		parent.replaceChildren( ...children );
  }
  
  setBibText( bibText ) {
	  // Return true if bibText changed.
	  let bibTextSave = this.bibText;
	  this.bibText = bibText;
	  this.normalizeBibs();
	  return this.bibText !== bibTextSave;
  }
  
  get actionTypeDisplay() {
	  return actionTypeDisplay( this.actionType );
  }
  
  apply( e ) {
    if( !actionResult.has(this.actionType) )
      return;

    let bibs = e.cleanBibs( this.getBibsFromText() );
    let bibRiders = bibs.map( (bib) => e.getRider(bib) );

    switch( this.actionType ) {
      case ActionType.sprint: {
        // Account for ties.
        let finishOrder = bibs.map( (bib, i) => i + 1 );
        for( let i = 1; i < finishOrder.length; ++i ) {
          if( bibs[i] < 0 )
            finishOrder[i] = finishOrder[i-1];
        }
        
        // Assign points for the sprint.  Account for ties.
        ++e.sprintCount;
        let points = e.getPointsForPlace();
        for( let i = 0, j = 0; i < points.length && i < finishOrder.length; ++i ) {
          let place = i + 1;
          for( ; j < finishOrder.length && finishOrder[j] === place; ++j ) {
            bibRiders[j].pointsOnSprint.set( e.sprintCount, points[i] );
            e.sprintResults.push( new SprintResult(e.sprintCount, place, points[i], bibs[j]) );
          }
        }

        // If this is the final sprint, assign the finish order.
        if( e.sprintCount === e.sprintMax )
			bibRiders.forEach( (rider, i) => rider.finishOrder = finishOrder[i] );

        // Assign finish order to the pulled riders in reverse pull sequence.
        // Add back riders DNF'd or DSQ'd between pulls so we get the finish sequence at the time of the pull.
        let pulled = e.getPulled();
        let pullSequenceLast = -1;
        let finishOrderCur = finishOrder.length;
        for( let rider of pulled ) {
          if( rider.pullSequence !== pullSequenceLast ) {
				finishOrderCur += 1 + e.pullEliminatedCount[rider.pullSequence];
            pullSequenceLast = rider.pullSequence;
          }
          rider.finishOrder = finishOrderCur;
        }
        break;
      }
      case ActionType.lapUp:
		bibRiders.forEach( (rider) => ++rider.upDown );
        break;
      case ActionType.lapDown:
		bibRiders.forEach( (rider) => --rider.upDown );
        break;
      case ActionType.pul:
        ++e.pullSequenceCur;
		bibRiders.forEach( (rider) => rider.pullSequence = e.pullSequenceCur );
        break;
      case ActionType.dnf:
		bibRiders.forEach( (rider) => rider.status = Status.dnf );
        e.pullEliminatedCount[e.pullSequenceCur] += bibs.length;
        break;
      case ActionType.dns:
		bibRiders.forEach( (rider) => rider.status = Status.dns );
        break;
      case ActionType.dsq:
		bibRiders.forEach( (rider) => rider.status = Status.dsq );
        e.pullEliminatedCount[e.pullSequenceCur] += bibs.length;
        break;
      default:
        break;
    }
  }
}

var EventType = new Enum (
	'points',
	'madison',
	'tempo',
	'scratch',
	'snowball'
);
var EventUsesPoints = new Set( [EventType.points, EventType.madison, EventType.tempo, EventType.snowball] );

class Event {
  constructor() {
    this.eventType = EventType.points;
    this.sprintMax = 10;
    this.doublePointsLastSprint = true;
    this.pointsForPlace = [5,3,2,1];
    this.pointsForUpDown = 20;
	this.startingPoints = new Map();
    this.actions = [];
    
    // Values compute while processing actions.
	this.sprintCount = 0;
	this.pullSequenceCur = 0;
	this.pullEliminatedCount = [];	// Count of eliminated riders between pulls.
	this.sprintResults = [];
	this.riders = new Map();
	this.riderRank = [];	
  }

  cleanBibs( bibs ) {
	// Remove riders who are pulled or not finishers (DNS, DNF, DSQ, etc.).
    let bibsClean = [];
    for( let bib of bibs ) {
		const rider = this.getRider( bib );
		if( rider.isFinisher && !rider.isPulled )
			bibsClean.push( bib );
	}
    if( bibsClean.length > 0 && bibsClean[0] < 0 )	// First rider can't be tied.
      bibsClean[0] *= -1;
    return bibsClean;
  }

  get usesPoints() {
	  return EventUsesPoints.has(this.eventType);
  }

  getRider( bib ) {
    bib = Math.abs(bib);
    let rider = this.riders.get( bib );
    if( rider === undefined )
		this.riders.set( bib, rider = new Rider(bib) );
	return rider;
  }

  getPointsForPlace( sprintCount ) {
	sprintCount = sprintCount || this.sprintCount;
	switch( this.eventType ) {
		case EventType.snowball:
			return [sprintCount];
		default:
			return (this.doublePointsLastSprint && sprintCount === this.sprintMax
			  ? this.pointsForPlace.map( (x) => x * 2 )
			  : this.pointsForPlace
			 );
	}
  }

  getPulled() {
	let pulled = [];
	for( let [bib, rider] of this.riders ) if( rider.isPulled ) pulled.push( rider );
	pulled.sort( (a, b) => -(a.pullSequence - b.pullSequence) ); // Sort by decreasing pull sequence.
	return pulled;
  }

  setParameters() {
    switch( this.eventType ) {
      case EventType.points:
      case EventType.madison:
        this.pointsForPlace = [5,3,2,1];
        this.pointsForUpDown = 20;
        this.doublePointsLastSprint = true;
        break;
      case EventType.tempo:
        this.pointsForPlace = [1];
        this.pointsForUpDown = 20;
        this.doublePointsLastSprint = false;
        break;
      case EventType.scratch:
        this.pointsForPlace = [];
        this.pointsForUpDown = 1;	// Required for counting +/- laps.
        this.doublePointsLastSprint = false;
        break;
      case EventType.snowball:
        this.pointsForPlace = [1];
        this.pointsForUpDown = 20;
        this.doublePointsLastSprint = false;
        break;
    }
  }

  getCmpRank() {
    switch( this.eventType ) {
      case EventType.points:
      case EventType.madison:
      case EventType.snowball:
        return (a, b) => a.cmpPoints(b);
      case EventType.tempo:
        return (a, b) => a.cmpTempo(b);
      case EventType.scratch:
        return (a, b) => a.cmpScratch(b);
    }
  }

  getCmpEq() {
      switch( this.eventType ) {
        case EventType.points:
        case EventType.madison:
        case EventType.snowball:
          return (a, b) => a.eqPoints(b);
        case EventType.tempo:
          return (a, b) => a.eqTempo(b);
        case EventType.scratch:
          return (a, b) => a.eqScratch(b);
      }
  }
  
  setActions( actions ) {
	  if( actions.length !== this.actions.length || this.actions.some( (a, i) => !a.cmpEq( actions[i] ) ) ) {
		  this.actions = actions;
		  this.processActions();
		  return true;
	  }
	 return false;
  }

  getSprintCount( iAction ) {
	  let sprintCount = 0;
	  for( ; iAction >= 0; --iAction )
	    if( this.actions[iAction].actionType === ActionType.sprint )
	      ++sprintCount;
	  return sprintCount;
  }

  processActions() {
    this.setParameters();

    // Intialize.
    this.sprintCount = 0;
    this.pullSequenceCur = 0;
	this.pullEliminatedCount = (new Array(this.actions.length)).fill( 0 );
    this.sprintResults.clear();
    this.riders.clear();
    this.riderRank.clear();

	// Add the starting points and apply the actions.
	this.startingPoints.forEach( (points, bib) => { this.getRider(bib).startingPoints = points; } );
	this.actions.forEach( (a) => a.apply(this) );

    // Sort the riders for the final ranking.
    this.riderRank = [];
    this.riders.forEach( (rider) => { rider.computePointsTotal(this); this.riderRank.push(rider); } );
    this.riderRank.sort( this.getCmpRank() );
 }
}

var eventCur = new Event();

//----------------------------------------------------------------------

function createChild( parent, element, attributes={}, cls='' ) {
	let e = document.createElement( element );
	parent.appendChild( e );
	for( const [key, value] of Object.entries(attributes) )
		e.setAttribute( key, value );
	if( cls.length > 0 )
		e.className = cls;
	return e;
}

function createSpace( parent ) {
	parent.appendChild( document.createTextNode(' ') );
}

function addButton( parent, name, cls, handler ) {
	let button = createChild( parent, 'button' );
	button.innerHTML = name;
	button.className = cls;
	button.addEventListener( 'click', handler );
	return button;
}

function removeOverflowChildren( parent, N ) {
	for( let k = parent.children.length - N; k > 0; --k )
		parent.removeChild( parent.lastElementChild );
}

//----------------------------------------------------------------------
function commitActions() {
	// Screen ==> Model, updating the results table.
	let actionsTable = document.getElementById( 'idActions' );
	let rows = actionsTable.tBodies[0].children;
	let actions = [];
	for( let i = 0; i < rows.length; ++i ) {
		let actionType = parseInt(rows[i].id, 10), bibs = rows[i].children[2].innerText;
		if( !Number.isNaN(actionType) )
			actions.push( new Action(actionType, bibs) );
	}
	if( eventCur.setActions(actions) )
		refreshResults();
}

//----------------------------------------------------------------------
var rowDrag = null;
function dragActionStart( e ) {
	rowDrag = e.target;
}
function dragActionOver( e ) {
	let target = e.target;
	// Ensure the drop target is a td element (child of a tr).
	while( !(target.parentNode instanceof HTMLTableRowElement) )
		target = target.parentNode;
		
	let children = Array.from( target.parentNode.parentNode.children );
	if( children.indexOf(target.parentNode) > children.indexOf(rowDrag) )
		target.parentNode.after( rowDrag );
	else
		target.parentNode.before( rowDrag );
}
function dragActionEnd( e ) {
	commitActions();
	refreshActions();
}
//----------------------------------------------------------------------

function refreshActions() {
	// Model ==> Screen.
	let e = eventCur;
	let actionsTable = document.getElementById( 'idActions' );

	let headers = ['', 'Action', 'Bibs'];
	if( !actionsTable.querySelector('thead') ) {
		let thead = createChild( actionsTable, 'thead' );
		let tr = createChild( thead, 'tr' );
		let iCol = 0;
		for( let h of headers ) {
			let th = tr.children[iCol++] || createChild(tr, 'th');
			th.textContent = h;
		}
	}
	let tbody = actionsTable.tBodies[0] || createChild( actionsTable, 'tbody' );
	
	let iRow = 0, spCount = 0;
	for( let action of e.actions ) {
		let tr = tbody.children[iRow++] || createChild(tbody, 'tr');
		tr.id = action.actionType.toString();
		tr.draggable = true;
		tr.ondragstart = dragActionStart;
		tr.ondragover = dragActionOver;
		tr.ondragend = dragActionEnd;
				
		while( tr.children.length < 3 )
			createChild( tr, 'td' );
		
		let button = tr.children[0].querySelector('button');
		if( !button ) {
			button = createChild( tr.children[0], 'button' );
			//button.textContent = '\u2630';
			button.textContent = '\u2699';
			button.className = 'd-print-none';
		}
		button.onclick = ((iAction) => ( (e) => handleActionChange(e, iAction) ))(iRow-1);
		tr.children[1].textContent = action.actionTypeDisplay + (action.actionType === ActionType.sprint ? (++spCount).toString() : '');
		tr.children[1].className = actionResult.has(action.actionType) ? 'action-result' : 'action-note';
		action.setBibChildren( tr.children[2] );
	}
	removeOverflowChildren( tbody, e.actions.length );
}

function refreshResults() {
	// Model ==> Screen.
	let e = eventCur;
	e.processActions();
	
	let iCol = 0, iRow = 0;

	let resultsTable = document.getElementById( 'idResults' );

	// Process ties in the final ranking.
	let rank = e.riderRank.map( (rider, i) => i+1 );
	let eq = e.getCmpEq();
	for( let i = 1; i < e.riderRank.length; ++i ) {
		if( eq(e.riderRank[i-1], e.riderRank[i]) )
			rank[i] = rank[i-1];
	}

	// Create the columns.
	let colNames = [];
	let iRankCol = colNames.length; colNames.push( 'Rank' );
	let iBibCol = colNames.length; colNames.push( 'Bib' );
	let iPointsCol = -1;
	if( e.usesPoints ) {
		iPointsCol = colNames.length;
		colNames.push( 'Points' );
	}
	let iStartingPointsCol = -1;
	if( e.usesPoints && e.riderRank.some( (r) => r.startingPoints !== 0 ) ) {
		iStartingPointsCol = colNames.length;
		colNames.push( 'Start Pts' );
	}
	let iUpDownCol = colNames.length; colNames.push( '+/-Laps' );

	let iSprintCol = colNames.length;
	for( let i = 1; i <= e.sprintMax; ++i )
		colNames.push( 'Sp' + i );
	
	let iFinishCol = colNames.length;
	colNames.push( 'Finish' );

	let thead = (resultsTable.tHead || createChild( resultsTable, 'thead' ));
	let header = (thead.children[0] || createChild( thead, 'tr' ));
	for( let col of colNames ) {
		let th = header.children[iCol++] || createChild( header, 'th' );
		th.className = 'text-right';
		th.textContent = col;
	}
	removeOverflowChildren( header, colNames.length );

	// Update the results for Rank, Bib, Points, UpDown and Finish.
	let rows = [];
	for( let i = 0; i < e.riderRank.length; ++i ) {
		const r = e.riderRank[i];
		let row = Array(colNames.length).fill('');
		row[iRankCol] = (r.isFinisher ? rank[i].toString() : r.getStatusDisplay );
		row[iBibCol] = r.bib.toString();
		if( iPointsCol >= 0 )
			row[iPointsCol] = formatNonZero( r.pointsTotal );
		row[iUpDownCol] = formatNonZero( r.upDown * e.pointsForUpDown ); // pointsForUpDown must be 1 for scratch.
		if( r.isFinisher && r.finishOrder !== finishUnplaced )
			row[iFinishCol] = (r.isPulled ? '(p)\u00A0' : '') + r.finishOrder.toString();
		rows.push( row );
	}
	
	// Fill in the specific sprint results.
	if( e.usesPoints ) {
		// Create a map from bib to row.
		let bibToRow = new Map();
		e.riderRank.forEach( (rider, i) => bibToRow.set(rider.bib, i) );
			
		if( iStartingPointsCol >= 0 )
			e.riderRank.forEach( (rider, i) => rows[i][iStartingPointsCol] = rider.startingPoints.toString() );

		// Ignore extra sprints.
		eventCur.sprintResults.forEach(
			(s) => {
				if( s.sprint <= eventCur.sprintMax )
					rows[bibToRow.get(s.bib)][iSprintCol + s.sprint - 1] = formatNonZero(s.points);
			}
		);
	}

	// Apply the content to the table.
	let tbody = resultsTable.tBodies[0] || createChild( resultsTable, 'tbody' );
	iRow = 0;
	for( let row of rows ) {
		let tr = (tbody.children[iRow++] || createChild( tbody, 'tr' ));
		iCol = 0;
		for( let value of row ) {
			let td = (tr.children[iCol++] || createChild( tr, 'td' ));
			td.className = 'text-right';
			td.textContent = value;
		}
		removeOverflowChildren( tr, row.length );
	}
	removeOverflowChildren( tbody, rows.length );
}

function refreshAll() {
	refreshActions();
	refreshResults();
	refreshEventTitle();
}

//----------------------------------------------------------------------

var iActionCur = -1;

function handleDialogAction( actionType ) {
		
	document.getElementById('idActionDialog').close();

	let bibs = document.getElementById('idBibText').value;
	
	if( iActionCur < 0 ) {
		// This is a new action.
		let a = new Action( actionType, bibs );
		if( !(actionResult.has(actionType) && a.bibText === '') ) {
			eventCur.actions.push( a );
			refreshActions();	// Model => Screen
			if( actionResult.has(actionType) )
				refreshResults();
		}
	}
	else {
		// This is a change to the existing action.
		let a = eventCur.actions[iActionCur];
		if( a.actionType === actionType ) {
			// The actionType is unchanged.  Change the bibs.
			a.setBibText( bibs );
			refreshActions();	// Model => Screen
			if( actionResult.has(actionType) )
				refreshResults();
		}
		else {
			// The actionType changed.  Create a new action with the given bibs.
			a = new Action( actionType, bibs );
			if( !(actionResult.has(actionType) && a.bibText === '') ) {
				eventCur.actions.push( a );
				refreshActions();	// Model => Screen
				if( actionResult.has(actionType) )
					refreshResults();
			}
		}
	}
}

function handleDialogOK() {
	if( iActionCur < 0 ) {
		// If this is a new action, default to sprint.
		handleDialogAction( ActionType.sprint );
	}
	else {
		// If we are editing an existing action, just change the bib text.
		let bibs = document.getElementById('idBibText').value;
		if( eventCur.actions[iActionCur].setBibText(bibs) ) {
			refreshActions();
			refreshResults();
		}
		document.getElementById('idActionDialog').close();
	}
}

function handleDialogNew() {
	// Make a new copy of the existing event.
	let action = eventCur.actions[iActionCur];
	iActionCur = -1;
	handleDialogAction( action.actionType );
}

function handleDialogDelete() {
	document.getElementById('idActionDialog').close();
	
	let action = eventCur.actions[iActionCur];
	document.getElementById('idDeleteConfirmActionName').innerHTML = action.actionTypeDisplay + (action.actionType === ActionType.sprint ? eventCur.getSprintCount(iActionCur) : '');
	document.getElementById('idDeleteConfirmBibText').innerHTML = action.bibText;
	document.getElementById('idDeleteConfirmOK').onclick = function() {
		eventCur.actions.splice( iActionCur, 1 );
		refreshActions();
		refreshResults();
		iActionCur = -1;
		document.getElementById('idDeleteConfirmDialog').close();
	};
	document.getElementById('idDeleteConfirmCancel').onclick = function() {
		document.getElementById('idDeleteConfirmDialog').close();
	};
	
	document.getElementById('idDeleteConfirmDialog').showModal();
}

function handleDialogCancel() {
	document.getElementById('idActionDialog').close();
}

function fixActionName( name ) {
	name = name.toUpperCase();
	name = name.replace('GROUP', '');
	name = name.replace('LAPUP', '+Lap');
	name = name.replace('LAPDOWN', '-Lap');
	name = name.replace('SPRINT', 'Sp');
	if( name.length > 3 && name.match(/^[A-Z]/) )
		name = name[0] + name.slice(1).toLowerCase();
	return name;
}

function actionTypeDisplay( actionType ) {
	return fixActionName( ActionType.name(actionType) );
}
	
function addActionButtons() {
	let div = document.getElementById( 'idActionButtons' );
	div.innerHTML = '';
	
	let firstTime = true;
	let parent = createChild( div, 'p' );
	for( let key of ActionType.keys ) {
		if( actionResult.has( ActionType[key] ) ) {
			if( !firstTime )
				createSpace( parent );
			let button = addButton( parent, fixActionName(key).replace('Sp','Sprint'), 'result-button', ((action) => (() => handleDialogAction(action)))(ActionType[key]) );
			button.id = 'action_' + ActionType[key];
			firstTime = false;
		}
	}
	firstTime = true;
	parent = createChild( div, 'p' );
	for( let key of ActionType.keys ) {
		if( actionNote.has( ActionType[key] ) ) {
			if( !firstTime )
				createSpace( parent );
			let button = addButton( parent, fixActionName(key), 'note-button', ((action) => (() => handleDialogAction(action)))(ActionType[key]) );
			button.id = 'action_' + ActionType[key];
			firstTime = false;
		}
	}
}

function addControlButtons( isEdit ) {
	let div = document.getElementById( 'idControlButtons' );
	div.innerHTML = '';
	
	addButton( div, 'OK', 'btn btn-success', handleDialogOK ).id = 'idDialogOK';
	if( isEdit ) {
		createSpace( div );
		addButton( div, 'New', 'btn btn-primary', handleDialogNew ).id = 'idDialogNew';
		createSpace( div );
		addButton( div, 'Delete', 'btn btn-warning', handleDialogDelete ).id = 'idDialogDelete';
	}
	createSpace( div );
	addButton( div, 'Cancel', 'btn btn-light', handleDialogCancel ).id = 'idDialogCancel';
}

function openDialog( isEdit=false ) {
	addControlButtons( isEdit );

	function resetDialog() {
		document.getElementById('idActionName').innerHTML = '';
		document.getElementById('idBibText').value = '';
	}
	
	if( !isEdit ) {
		iActionCur = -1;
		resetDialog();
	}
	else {
		let action = eventCur.actions[iActionCur];
		if( action ) {
			document.getElementById('idActionName').textContent = action.actionTypeDisplay + (action.actionType === ActionType.sprint ? eventCur.getSprintCount(iActionCur) : '');
			document.getElementById('idBibText').value = action.bibText;
		}
		else
			resetDialog();
	}
	document.getElementById('idActionDialog').showModal();
}

function handleActionChange( e, iAction ) {
	iActionCur = iAction;
	openDialog( true );
}

//----------------------------------------------------------------------

function fixFilename( f ) {
	return f.replace( new RegExp('[#%&{}\\<>*? \t\n\r$!\'":@+\`|=/]+', 'g'), '_' );
}

function capitalizeTitle( name ) {
	name = '' + name;
	return name[0].toUpperCase() + name.slice(1).toLowerCase();
}

function csvField( value ) {
	value = '' + value;
	if( value.includes(',') || value.includes('"') )
		value = '"' + value.replace( '"', '""' ) + '"';
	return value;
}

function getFileName() {
	return fixFilename(
		(document.getElementById('idEventName').value.trim() || 'Event' ) + '-' +
		capitalizeTitle(EventType.name(eventCur.eventType))
	) + '.csv';
}

function dateWithoutTimezone( date ) {
  const tzoffset = date.getTimezoneOffset() * 60000; //offset in milliseconds
  const withoutTimezone = new Date(date.valueOf() - tzoffset)
    .toISOString()
    .slice(0, -1);
  return withoutTimezone;
};

function saveToCsv() {
	let csvContent = [];

	csvContent.push( '[Info]' );
	
	const name = document.getElementById( 'idEventName' ).value.trim() || 'Event';
	csvContent.push( ['Name', csvField(name)].join(',') );
	csvContent.push( ['Type', capitalizeTitle(EventType.name(eventCur.eventType))].join(',') );
	csvContent.push( ['Sprints', eventCur.sprintMax].join(',') );
	csvContent.push( ['Timestamp', dateWithoutTimezone( new Date() )].join(',') );
	csvContent.push( ['Version', csvField(version)].join(',') );
	csvContent.push( ['Credit', 'Edward Sitarski, 2023'].join(',') );
	
	csvContent.push( '[Results]' );
	let resultTable = document.getElementById( 'idResults' );
	for( let row of resultTable.rows ) {
		let csvRow = [];
		for( let cell of row.cells )
			csvRow.push( csvField(cell.textContent) );
		csvContent.push( csvRow.join(',') );
	}
	
	// Add the action information.
	csvContent.push( '[Actions]' );
	for( let action of eventCur.actions )
		csvContent.push( [action.actionTypeDisplay, action.bibText].join(',') );
	
	// Send the output as a string.
	csvContent = csvContent.join( '\n' );
	const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8,' });
	const objUrl = URL.createObjectURL( blob );
	
	let link = document.getElementById('idDownloadLink') || createChild(document.querySelector('body'), 'a');
	link.id = 'idDownloadLink';
	link.setAttribute('href', objUrl);
	link.setAttribute('download', getFileName());
	link.textContent = '';
	link.click();
}

// Credit to: https://github.com/peterthoeny/parse-csv-js/blob/master/parse-csv.js
function parseCsv(data, fieldSep, newLine) {
  fieldSep = fieldSep || ',';
  newLine = newLine || '\n';
  const nSep = '\x1D';
  const nSepRe = new RegExp(nSep, 'g');
  const qSep = '\x1E';
  const qSepRe = new RegExp(qSep, 'g');
  const cSep = '\x1F';
  const cSepRe = new RegExp(cSep, 'g');
  const fieldRe = new RegExp('(^|[' + fieldSep + '\\n])"([^"]*(?:""[^"]*)*)"(?=($|[' + fieldSep + '\\n]))', 'g');
  return data
    .replace(/\r/g, '')
    .replace(/\n+$/, '')
    .replace(fieldRe, (match, p1, p2) => {
      return p1 + p2.replace(/\n/g, nSep).replace(/""/g, qSep).replace(/,/g, cSep);
    })
    .split(/\n/)
    .map(line => {
      return line
        .split(fieldSep)
        .map(cell => cell.replace(nSepRe, newLine).replace(qSepRe, '"').replace(cSepRe, ','));
    });
}

function readImportFile( csv ) {
	
	function findCol( header, re ) {
		for( let i = 0; i < header.length; ++i ) {
			if( header[i].trim().match(re) ) {
				return i;
			}
		}
		return -1;
	}
	
	eventCur.startingPoints.clear();

	let grid = parseCsv( csv );
	if( grid.length < 2 )
		return;
		
	// Check if this is a Results format file.
	let iInfoRow = -1;
	for( let iRow = 0; iRow < grid.length; ++iRow ) {
		if( grid[iRow][0] === '[Info]' ) {
			iInfoRow = iRow;
			break;
		}
	}
	
	const bibRe = new RegExp( '^(Bib|Bibs|Num|Number|Numbers|#|Bib#|Bib #)$', 'i' );
	
	if( iInfoRow >= 0 ) {
		// Get the event info.
		let iRow = iInfoRow + 1;
		for( ; iRow < grid.length && grid[iRow][0] !== '[Results]'; ++iRow ) {
			if( grid[iRow][0] === 'Name' )
				document.getElementById( 'idEventName' ).value = grid[iRow][1];
			else if( grid[iRow][0] === 'Type' )
				eventCur.eventType = EventType.value(grid[iRow][1].toLowerCase()) || 0;
			else if( grid[iRow][0] === 'Sprints' )
				eventCur.sprintMax = parseInt( grid[iRow][1], 10 ) || 10;
		}

		if( iRow < grid.length && grid[iRow][0] === '[Results]' ) {
			const header = grid[++iRow];
			const iBibCol = findCol( header, bibRe );
			const iPointsCol = findCol( header, new RegExp( '^(Start Pts)$', 'i' ) );

			// Add the starting points.
			for( ++iRow; iRow < grid.length && grid[iRow][0] !== '[Actions]'; ++iRow ) {
				if( iBibCol >= 0 && iPointsCol >= 0 ) {	
					const bib = parseInt( grid[iRow][iBibCol], 10 );
					const points = parseInt( grid[iRow][iPointsCol], 10 );
					if( !Number.isNaN(bib) && !Number.isNaN(points) )
						eventCur.startingPoints.set( bib, points );
				}
			}

			// Read the Actions.
			if( iRow < grid.length && grid[iRow][0] === '[Actions]' ) {
				eventCur.actions.clear();
				
				// Create a map of all the action type names.
				let actionMap = new Map(), actionType = 0;
				for( let key of ActionType.keys )
					actionMap.set( fixActionName(key), actionType++ );
						
				for( ++iRow; iRow < grid.length; ++iRow ) {
					const actionType = actionMap.get( grid[iRow][0].trim() );
					const bibText = grid[iRow][1];
					if( actionType !== undefined )
						eventCur.actions.push( new Action(actionType, bibText) );
				}
			}
		}
	}
	else {
		// This is a Start Points import file.
		// Find the 'bib' and 'points' column.
		let pointsRe = new RegExp( '^(Points|Points|Pnt|Pnts|Pts)$', 'i' );
		let iBibCol = -1, iPointsCol = -1;
		let iRow = 0;
		for( ; iRow < grid.length; ++iRow ) {
			iBibCol = findCol( grid[iRow], bibRe );
			iPointsCol = findCol( grid[iRow], pointsRe );
			if( iBibCol >= 0 && iPointsCol >= 0 )
				break;
		}
		
		// Add the starting points to the riders.
		if( iBibCol >= 0 && iPointsCol >= 0 ) {	
			for( ++iRow; iRow < grid.length; ++iRow ) {
				const bib = parseInt( grid[iRow][iBibCol], 10 );
				const points = parseInt( grid[iRow][iPointsCol], 10 );
				if( !Number.isNaN(bib) && !Number.isNaN(points) )
					eventCur.startingPoints.set( bib, points );
			}
		}
	}
	
	refreshAll();
}

function importCsvFile() {
	const content = document.querySelector(".content");
	const [file] = document.querySelector("input[type=file]").files;
	const reader = new FileReader();

	reader.addEventListener( "load", () => { readImportFile(reader.result); }, false );

	if( file )
		reader.readAsText( file );
}

//----------------------------------------------------------------------

function refreshEventTitle() {
	let value = (
		document.getElementById('idEventName').value.trim() +
		' | Type: ' + capitalizeTitle( EventType.name(eventCur.eventType) ) +
		' | Sprints: ' + eventCur.sprintMax
	);
	document.getElementById('idEventTitle').textContent = value;
	
	value = document.getElementById('idEventName').value.trim() + ' | ' + 'PointsRaceWeb';
	document.getElementById('idTitle').textContent = value;
}

function changeEventType( e ) {
	eventCur.eventType = parseInt( e.target.value, 10 );
	if( eventCur.eventType === EventType.scratch ) {
		document.getElementById( 'idSprintMaxLabel' ).hidden = true;
		document.getElementById( 'idSprintMax' ).hidden = true;
		eventCur.sprintMax = 1;
	}
	else {
		document.getElementById( 'idSprintMaxLabel' ).hidden = false;
		document.getElementById( 'idSprintMax' ).hidden = false;
		eventCur.sprintMax = parseInt( document.getElementById( 'idSprintMax' ).value, 10 )  || 1;
	}
	refreshAll();
}

function toggleHelp( e ) {
	let help = document.getElementById('idHelp');
	let helpButton = document.getElementById('idHelpButton');
	if( help.hidden ) {
		help.hidden = false;
		helpButton.textContent = "Hide Help";
	}
	else {
		help.hidden = true;
		helpButton.textContent = "Show Help";
	}
}

function onLoad() {
	
	window.onbeforeunload = function() {
		return "Leaving will lose your data.  Continue?";
	};
	
	let eventTypeSelect = document.getElementById('idEventType');
	let firstTime = true;
	for( let key of EventType.keys ) {
		let option = createChild( eventTypeSelect, 'option' );
		option.value = EventType.value( key );
		option.text = key[0].toUpperCase() + key.slice(1);
		if( firstTime ) {
			firstTime = false;
			option.selected = true;
		}
	}
	eventTypeSelect.onchange = changeEventType;
	
	addActionButtons();
	document.getElementById('idBibText').addEventListener(
		'keypress',
		function( e ) {
			if( e.key === 'Enter' ) {
				e.preventDefault();
				document.getElementById('idDialogOK').click();
			}
		}
	);
	
	let eventName = document.getElementById('idEventName');
	eventName.addEventListener( 'change', refreshEventTitle );
	
	let sprintMax = document.getElementById('idSprintMax');
	sprintMax.value = eventCur.sprintMax;
	sprintMax.addEventListener(
		'change',
		function( e ) {
			eventCur.sprintMax = parseInt( e.target.value, 10 ) || 1;
			eventCur.processActions();
			refreshResults();
			refreshEventTitle();
		}
	);
	
	refreshAll();
}

</script>
</head>

<body onload="onLoad();">
	<button onclick="openDialog(false);"  type="button" class="round d-print-none">+</button><div class="divider"/>
	<span id="idEventTitle" style="font-size:175%; white-space: nowrap;"></span>
	<table>
		<row>
			<td><table id="idActions" class="hover-rows"></table></td>
			<td><table id="idResults" class="hover-rows"></table></td>
		</row>
	</table>
	<div class="d-print-none">
		<hr/>
		<label for="idEventName" >Name:</label><input type="text" id="idEventName"/><div class="divider"/>
		<label for="idEventType">Type:</label><select id="idEventType"></select><div class="divider"/>
		<label for="idSprintMax" id="idSprintMaxLabel">Sprints:</label><input type="number" min="1" max="50" id="idSprintMax"/>
		<p></p>
		<button onclick="saveToCsv();"  type="button" class="button3">Save</button><div class="divider"/>
		<label for="idFileImport">Load</label><input type="file" accept=".csv" onchange="importCsvFile()" id="idFileImport" class="button3"/ ><div class="divider"/>
		<button onclick="toggleHelp()" id="idHelpButton" type="button" class="button3">Show Help</button>
	</div>
	<hr/>
	<div class="slide-left center">
		<img src="data:image/png;base64,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" />
		<em>
				<span style="font-size:120%; padding-left: 8px">
					<script>document.write(version)</script>
					by Edward Sitarski, (Toronto, Canada 2023-<script type="text/javascript">document.write(new Date().getFullYear());</script>)
					</span>
		</em>
	</div>
	
	<div id="idHelp" hidden="true">
		<h2><script>document.write(version)</script> by Edward Sitarski</h2>
		<h4>Score Points, Madison, Tempo, Scratch and Snowball Races Quickly and Accurately</h4>
		<h4>Disclaimer</h4>
		<p>
			The user assumes all responsibilty for results created by this software.<br/>
			It comes with no guarantee or warranty.<br/>
			Every effort has been taken to ensure the results are accurate, however, errors are always possible.<br/>
			Always check the results manually.  If you find errors, contact the author.<br/>
			This software is for personal use only.
			For commercial use, contact the author.<br/>
		</p>
		<h4>Basic Usage: Actions</h4>
		<p>
			<ul>
				<li>Configure the <strong>Name</strong>, <strong>Type</strong> (Points, Madison, Tempo, Scratch, Snowball) and the number of <strong>Sprints</strong> for the race.<br/>
					This can be changed at any time.<br/>
					For example, set Name=Test, Type=Points and Sprints=4.
				</li>
				<li>Press the <strong></strong> button at the top to create an Action</li>
				<li>In the Action dialog, enter the Bibs and click the Action Type:<br/>
					<strong>Sprint, +Lap, -Lap, PUL, DNF, DNS, DSQ</strong>
				</li>
				<li>
					For example, press <strong></strong>, set <strong>Bibs: 10 20 30 40</strong>, then click <strong>Sprint</strong> (or press Enter).<br/>
					Then, press <strong></strong>, then <strong>Bibs: 20 30 40 -50</strong>, then click <strong>Sprint</strong> (or press Enter).<br/>
					A minus in front of a bib number indicates a tie.  In this, case 40 and 50 are tied for 3th place.
				</li>
				<li>Results are updated instantly</li>
				<li>Press the <strong>&#9881;</strong> button next to each Action to Edit or Delete it.<br/>
					In our example, change the Bibs in the last Sprint to 20 30 40 60.<br/>
					Press <strong>&#9881;</strong> next to Sp2 now, change 50 to 60 in the dialog, the press Enter or click on OK.
				</li>
				<li>Drag and Drop Action rows to change the order<br/>
					In our example, press on "Sp2" Action and drag it on top of the "Sp1" Action.  The rows will exchange.<br/>
				</li>
				<li>In the last Sprint, enter the full finish order.
				</li>
			</ul>
		</p>
		<h4>Advanced Usage: Potential Actions</h4>
		<p>
			<ul>
				<li>Create potential Actions that have not happened yet, then convert them to real Actions quickly:<br/>
					<strong>Break, Chase, OTB, NML, Cmpct</strong>
				</li>
				<li>
					In our example, create <strong>Break 10 20 30 70 80 90</strong> showing riders who are ahead 1/2 a lap after Sp2.
				</li>
				<li><strong>10 20 30 70 80 90</strong> gain a lap.<br/>
					Press the <strong>&#9881;</strong> button next to <strong>Break 10 20 30 70 80 90</strong>.<br/>
					Then press the <strong>+ Lap</strong> button in the Actions dialog. .<br/>
					This creates a new <strong>+ Lap</strong> action based on the existing <strong>Break</strong>.<br/>
					A new Action is created whenever you press a Type button different from the current Action type.<br/>
					To create a new Action with the same type, press <strong>New</strong>.<br/>
				</li>
				<li>Say 10 20 30 70 80 90 do not gain a lap and all go back into the pack.<br/>
					Create a <strong>Cmpct</strong> Action to record the group is together again.<br/>
					There is no need to delete the Break Action - leave it there as documentation.
				</li>
				<li>Potential Actions make it easy to respond quickly to the evolving race situation.
				</li>
				<li>Unwanted or extra actions can be deleted.  Press <strong>&#9881;</strong>, then <strong>Delete</strong> from the dialog.
				</li>
			</ul>
		</p>
		<h4>Saving and Loading</h4>
		<p>
			<ul>
				<li><strong>Save</strong> saves the race to your Downloads folder in .csv format.<br/>
					The browser will not overwrite an existing file.  It will create numbered versions.<br/>
					You can open the saved .csv file in Excel.  If you edit it, save it as an .xlsx.<br/>
					Otherwise, PointsRaceWeb may not be able to read it again.
				</li>
				<li><strong>Load</strong> will load previously saved PointsRaceWeb .csv files.</li>
				<li><strong>Load</strong> will also load .csv files with column headers "Bib" and "Points".<br/>
				Use this to initialize the starting points in an Ominium Points Race.<br/>
				Other column names in the .csv file are ignored.
				</li>
			</ul>
		</p>
		<h4>Notes</h4>
		<p>
			<ul>
				<li><strong>Ties:</strong> indicated by a <strong>-</strong> in front of the bib number.<br/>
				<strong>Sprint: 10 20 -30 40</strong> means that 20 and 30 tied for second place, with 40 in forth.<br/>
				N-way ties: <strong>Sprint: 10 -20 -30 40</strong> means that 10, 20 and 30 all tied for first place, with 40 in forth.<br/>
				</li>
			</ul>
			<ul>
				<li><strong>Pulled riders:</strong> will be given a finish order based on the number or riders remaining on the track at the time they were pulled.<br/>
				</li>
			</ul>
		</p>
		<p>
			Questions and Comments?  <a href="mailto:edward.sitarski@gmail.com">Send email</a>
		</p>
	</div>
</body>

<dialog id="idActionDialog">
	<h3 id="idActionName"></h3>
	<label for="idBibText">Bibs:</label><input type="text" id="idBibText" size="50" /><br/>
	<div id="idActionButtons"></div>
	<div id="idControlButtons"></div>
</dialog>

<dialog id="idDeleteConfirmDialog">
	<h4>Confirm Delete?</h4>
	<h3 id="idDeleteConfirmActionName"></h3>
	<span>Bibs:</span>
	<span id="idDeleteConfirmBibText" style="font-size:110%"></span><br/>
	<p></p>
	<div id="idDeleteConfirmButtons">
		<button id="idDeleteConfirmOK" class="btn btn-warning">OK</button>
		<button id="idDeleteConfirmCancel" class="btn btn-success">Cancel</button>
	</div>
</dialog>


</html>
